import java.util.Arrays;

public class OptimalWarehousePlacement {

    /**
     * Problem: Optimal Warehouse Placement
     *
     * You are given the coordinates of N warehouses and M clients.  Each warehouse has a capacity.
     * Each client has a demand.  Find the optimal placement of warehouses to minimize the total distance
     * from clients to their assigned warehouses, subject to warehouse capacity constraints.  Assume
     * Euclidean distance.
     *
     * Input:
     *  - warehouses: An array of Warehouse objects. Each Warehouse has coordinates (x, y) and capacity.
     *  - clients: An array of Client objects. Each Client has coordinates (x, y) and demand.
     *
     * Output:
     *  - The minimum total distance, or -1 if no feasible solution exists.
     */


    static class Warehouse {
        int x, y, capacity;
        int assignedClients; // Added to track capacity

        public Warehouse(int x, int y, int capacity) {
            this.x = x;
            this.y = y;
            this.capacity = capacity;
            this.assignedClients = 0;
        }
    }

    static class Client {
        int x, y, demand;
        Warehouse assignedWarehouse;

        public Client(int x, int y, int demand) {
            this.x = x;
            this.y = y;
            this.demand = demand;
        }
    }

    public static double solve(Warehouse[] warehouses, Client[] clients) {
        Arrays.sort(warehouses, (a, b) -> a.capacity - b.capacity); //Sort by capacity for better heuristic
        double minDistance = -1;
        for (int i = 0; i < (1 << (warehouses.length * clients.length)); i++) { //Brute-force approach (Can be optimized with heuristics)
            double currentDistance = 0;
            boolean feasible = true;
            Arrays.fill(warehouses, new Warehouse(0,0,0)); //Reset warehouses capacity

            int k = i;
            for (int j = 0; j < clients.length; j++) {
                int warehouseIndex = -1;
                for (int l = 0; l < warehouses.length; l++) {
                    if ((k % 2) == 1) {
                        warehouseIndex = l;
                        break;
                    }
                    k /= 2;
                }
                if (warehouseIndex == -1) continue;

                if(warehouses[warehouseIndex].capacity < clients[j].demand + warehouses[warehouseIndex].assignedClients) {
                  feasible = false;
                  break;
                }

                double dist = distance(clients[j], warehouses[warehouseIndex]);
                currentDistance += dist;
                warehouses[warehouseIndex].assignedClients += clients[j].demand;
                clients[j].assignedWarehouse = warehouses[warehouseIndex];
            }


            if (feasible) {
                if (minDistance == -1 || currentDistance < minDistance) {
                    minDistance = currentDistance;
                }
            }
        }
        return minDistance;
    }


    static double distance(Client c, Warehouse w) {
        return Math.sqrt(Math.pow(c.x - w.x, 2) + Math.pow(c.y - w.y, 2));
    }


    public static void main(String[] args) {
        Warehouse[] warehouses = {
                new Warehouse(1, 1, 10),
                new Warehouse(5, 5, 15),
                new Warehouse(10,10, 5)
        };
        Client[] clients = {
                new Client(2, 2, 5),
                new Client(6, 6, 8),
                new Client(9,9, 3)

        };

        double minTotalDistance = solve(warehouses, clients);
        System.out.println("Minimum total distance: " + minTotalDistance);
    }
}